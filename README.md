# Countries Explorer

💻 **دموی آنلاین:** [Live Demo](https://sina-rahimi-digify.vercel.app/?page=3)

---

## نوحه اجرا

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

---

## ساختار پروژه

من از معماری **FSD (Feature Sliced Design)** استفاده کرده‌ام ([مستندات](https://feature-sliced.design/docs/get-started/overview)).
بطور کلی، فلسفه این معماری را دوست دارم و تقسیم اپلیکیشن به موجودیت‌ها، فیچرها و ویجت‌های کوچک‌تر، کدنویسی را برایم لذت‌بخش‌تر می‌کند.
سعی کردم کامپوننت‌ها و بلوک‌های UI که ممکن است در آینده قابل استفاده مجدد باشند را تا جای ممکن **reusable** بنویسم.

---

## عملکرد پروژه

### بارگذاری اولیه

- پروژه ابتدا داده‌ها را از API روی سرور fetch می‌کند.
- یک **helper function** به نام `fetcher` ایجاد شده که قابلیت استفاده مجدد دارد.
- نتیجه درخواست‌ها با **cache** ذخیره می‌شود تا در ریکوئست‌های بعدی، پاسخ از cache گرفته شود.
- HTML اولیه با داده‌ها روی سرور ساخته می‌شود.
- مقادیر اولیه مورد نیاز Store که باید در first load پروژه مقداردهی شوند ست شده و صفحه اول رندر می‌شود.

### ویو دسکتاپ

- کامپوننت **Pagination** تغییرات URL Param برای جستجو را مدیریت می‌کند.
- پس از لود اولیه، تنها داده‌های JSON از سرور دریافت می‌شوند و مرورگر صفحات بعدی را رندر می‌کند.

### ویو موبایل

- چندین راه حل بررسی شد:

  1. تشخیص موبایل یا دسکتاپ در سرور و لود صفحه متناسب: باعث می‌شد پروژه **ریسپانسیو** نباشد و تغییر سایز مرورگر به درستی کار نکند.
  2. پیاده‌سازی کامل Infinite Scroll روی client-side: با توجه به اینکه تسک نیاز داشت صفحه اول SSR باشد، امکان پیاده‌سازی جداگانه نبود.
  3. رندر داده‌ها تا صفحه فعلی و سپس ادامه با Infinite Scroll: اگر کاربر صفحه موبایل ۳۰ را باز کند، مرورگر فشار زیادی متحمل می‌شود که مناسب نیست.

- در نتیجه، Infinite Scroll به صورت یک **client-side component** دور داده‌های اولیه سمت سرور wrap شده است.
- با دو **loader** در بالا و پایین داده‌ها، اسکرول به بالا و پایین مدیریت می‌شود تا داده‌های بیشتری لود شود.
- با دو **anchor** میزان داده‌های لود شده قبل و بعد صفحه سرور مدیریت می‌شود.
- تصاویر به صورت **lazy load** بارگذاری می‌شوند.

```

```
